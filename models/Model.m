classdef (Abstract) Model < handle
    % Abstract Model Class

    methods (Abstract)
        % Returns true if the model has been fitted. 
        isFitted(obj);

        % Returns the estimated model coefficients.
        % If `excludeDeterministic` is true, coefficients corresponding to 
        % deterministic components (e.g., intercept, trend) are excluded.
        coeffs(obj, excludeDeterministic);
        
        % Returns the fitted values generated by the model after estimation.
        % These represent the model's predictions for the dependent variable(s).
        fitted(obj);

        % Returns the residuals of the model, defined as the difference between the
        % observed and fitted values.
        residuals(obj);

        % Returns the number of effective observations used during model estimation.
        % This excludes any initial observations lost due to lags or filtering.
        nobs(obj);

        % Returns the dependent variable(s) used in estimation as an array.
        % The format may be two- or three-dimensional, depending on the model.
        getDependent(obj);

        % Returns the independent variable(s) used in estimation as an array.
        % The output may include deterministic components (e.g., constant, trend),
        % represented explicitly (e.g., a column of ones for an intercept).
        % The format may be two- or three-dimensional, depending on the model.
        getIndependent(obj);

        % Returns the original input data used for model estimation, typically
        % in a tabular or matrix format (e.g., a table or matrix).
        getInputData(obj);

        % Returns true if the model is a structural model, i.e. if the model 
        % is causal.
        isStructural(obj);
        
        % Estimates the model parameters based on the provided input data.
        % This is the primary method for fitting the model.
        fit(obj);

        % Performs model selection among a set of candidate specifications,
        % then estimates the selected model.
        fitAndSelect(obj);
    end

    methods
        function requireFitted(obj)
            % `requireFitted` Ensure that the model has been estimated.
            %
            %   `requireFitted(obj)` checks whether the model `obj` has been fitted.
            %   If the model is not fitted, it throws an error of type `NotFitted`.
            %
            %   ## Arguments
            %   - `obj` (object): Model object that should have a method `isFitted`.
            %
            %   See also `isFitted`.
            if ~isFitted(obj)
                errId = class(obj) + ":NotFitted";
                errMsg = class(obj) + " has not been estimated.";
                error(errId, errMsg);
            end
        end

        function varsIdx = vars2idx_(obj, vars)
            % `vars2idx_` Map variable names or indices to their corresponding 
            %  column indices.
            %
            %   `vars2idx_(obj, vars)` returns the column indices corresponding 
            %   to the variables specified in `vars`. If `vars` is a numeric 
            %   array, it is returned unchanged. If `vars` is a character or 
            %   cell array of characters, the corresponding column indices in 
            %   the model data are returned.
            %
            %   ## Arguments
            %   - `obj` (object): Model object that must implement `getVariableNames`.
            %   - `vars` (integer, char, or cell array of char): Variables 
            %     specified either by their indices or names.
            %
            %   ## Returns
            %   - `varsIdx` (integer array): Column indices corresponding to 
            %     the requested variables.
            %
            %   ## Notes
            %   - This function is intended for internal use only.
            %   - If a variable name does not exist, an error is thrown.
            %
            %   See also `getVariableNames`.

            if ischar(vars)
                vars = {vars};
            end
            if ~iscell(vars) && ~isnumeric(vars)
                error("Variables must either be given using indices or variable names.");
            end
            if iscell(vars) && ~ischar(vars{1})
                error("If variables are given by names, they must be `char`.");
            end

            if isnumeric(vars)
                varsIdx = vars;
                return;
            end

            varnames = obj.getVariableNames();
            varsIdx = zeros(length(vars), 1);
            for i = 1:length(vars)
                idx = find(cellfun(@(c) isequal(c, vars{i}), varnames), 1, 'first');
                if isempty(idx)
                    error(vars{i} + " is not a valid variable name.");
                end
                varsIdx(i) = idx;
            end
        end

        function q = notThrough(obj, vars, horizons, order)
            % `notThrough` Create a transmission condition excluding specific 
            % variables from the channel.
            %
            %   `q = notThrough(obj, vars, horizons, order)` constructs a 
            %   transmission condition `q` where paths cannot pass through 
            %   specified variables at given time horizons.
            %
            %   ## Arguments
            %   - `obj` (object): A Model object.
            %   - `vars` (char or cell array of char): Name(s) of the variables 
            %     that paths cannot go through.
            %   - `horizons` (vector or cell array of vectors): Time horizons 
            %     at which the paths cannot pass through the variable(s).
            %   - `order` (char or cell array of char): Variable ordering defining
            %     the transission matrix.
            %
            %   ## Returns
            %   - `q` (Q): A transmission condition that can be used in 
            %     `transmission` to compute the transmission effect.
            %
            %   See also `through`, `transmission`

            varsIdx = obj.vars2idx_(vars);
            orderIdx = obj.vars2idx_(order);
            q = notThrough(varsIdx, horizons, orderIdx);
        end
        function q = through(obj, vars, horizons, order)
            % `through` Create a transmission condition enforcing paths through
            % specific variables.
            %
            %   `q = through(obj, vars, horizons, order)` constructs a
            %   transmission condition `q` where paths must pass through
            %   specified variables at given time horizons. 
            %
            %   ## Arguments
            %   - `obj` (object): A Model object.
            %   - `vars` (char or cell array of char): Name(s) of the
            %     variables that paths must go through.
            %   - `horizons` (vector or cell array of vectors): Time horizons at
            %     which the paths must pass through the variable(s).
            %   - `order` (char or cell array of char): Variable ordering defining
            %     the transmission matrix.
            %
            %   ## Returns
            %   - `q` (Q): A transmission condition that can be used in
            %     `transmission` to compute the transmission effect.
            %
            %   See also `notThrough`, `transmission`.
            varsIdx = obj.vars2idx_(vars);
            orderIdx = obj.vars2idx_(order);
            q = through(varsIdx, horizons, orderIdx);
        end
        function orderIdx = defineOrder(obj, order)
            % `defineOrder` Define the transmission ordering of variables in a 
            % model.
            %
            %   `defineOrder(obj, order)` specifies the ordering of variables 
            %   by their names and returns the corresponding indices used 
            %   internally by the model.
            %
            %   ## Arguments
            %   - `obj` (object): Model object that implements `vars2idx_`.
            %   - `order` (cell array of char): Ordered list of variable names.
            %
            %   ## Returns
            %   - `orderIdx` (integer array): Ordered indices corresponding 
            %     to the variable names.
            %
            %   See also `vars2idx_`, `getVariableNames`.

            orderIdx = obj.vars2idx_(order);
        end
        
    end
end
